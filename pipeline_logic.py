# -*- coding: utf-8 -*-
import sys
import os
import traceback # Para obtener más detalles de errores
import tempfile
import cv2 # Necesario para redimensionar

# Importar las funciones principales de los scripts de las fases v0.3
try:
    from video_analyzer import analyze_video_steps
    from extraer_screenshots import extract_screenshots
    from generar_docx_pdd import generate_pdd_docx_v0_3
except ImportError as e:
    print(f"Error Crítico: No se pudieron importar funciones de los scripts de fases.")
    print(f"Asegúrate de que 'video_analyzer.py', 'extraer_screenshots.py', y 'generar_docx_pdd.py' estén en la misma carpeta.")
    print(f"Detalle: {e}")
    sys.exit(1)

# --- Configuración Centralizada ---
PROJECT_ID = "pdd-agent-456515" # TU PROJECT ID
LOCATION = "us-central1"      # TU REGIÓN
MODEL_NAME = "gemini-2.5-pro-exp-03-25" # O el modelo PRO que uses

# Nombres de Archivos Intermedios/Salida
JSON_OUTPUT_PATH = 'full_analysis_output.json'
SCREENSHOT_DIR = 'screenshots_output'
OUTPUT_DOCX_PATH = 'PDD_Generated_Output_v0.3.docx'
OUTPUT_BPMN_PATH = 'Generated_Process.bpmn'

DEFAULT_USER_METADATA = {
    "project_name": "PDD Agent Process",
    "project_acronym": "PDDAGENT",
    "author_name": "AutoGenerated",
    "version": "0.3",
    "status": "BORRADOR"
}

# --- Configuración de Redimensionamiento (NUEVO) ---
RESIZE_VIDEO = True # Poner en False para deshabilitar el redimensionamiento
RESIZE_TARGET_WIDTH = 1280 # Ancho objetivo en píxeles (ej: 1280 para ~720p si es 16:9)
# --- Fin Configuración ---


def resize_video(input_path: str, output_path: str, target_width: int) -> bool:
    """
    Redimensiona un video a un ancho objetivo, manteniendo la proporción.

    Args:
        input_path (str): Ruta al video original.
        output_path (str): Ruta donde guardar el video redimensionado.
        target_width (int): Ancho deseado en píxeles.

    Returns:
        bool: True si el redimensionamiento fue exitoso, False en caso contrario.
    """
    print(f"[Resize] Intentando redimensionar '{input_path}' a ancho {target_width}px...")
    cap = cv2.VideoCapture(input_path)
    if not cap.isOpened():
        print(f"[Resize] Error: No se pudo abrir el video original '{input_path}'")
        return False

    # Obtener propiedades originales
    original_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    original_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    original_fps = cap.get(cv2.CAP_PROP_FPS)

    if original_width == 0 or original_height == 0:
        print(f"[Resize] Error: Dimensiones originales inválidas ({original_width}x{original_height}).")
        cap.release()
        return False

    # Si ya es más pequeño o igual, no redimensionar (opcional, pero ahorra trabajo)
    if original_width <= target_width:
        print(f"[Resize] El video ya tiene un ancho menor o igual ({original_width}px). No se redimensionará.")
        cap.release()
        # Consideramos esto un "éxito" en el sentido de que no falló,
        # pero la función principal usará la ruta original.
        # Devolvemos False para indicar que no se creó un *nuevo* archivo redimensionado.
        return False # No se creó archivo nuevo

    # Calcular nueva altura manteniendo proporción
    aspect_ratio = original_height / original_width
    target_height = int(target_width * aspect_ratio)
    new_size = (target_width, target_height)
    print(f"[Resize] Dimensiones originales: {original_width}x{original_height}. Nuevas: {target_width}x{target_height}")

    # Definir codec y crear VideoWriter (usar .mp4 para compatibilidad)
    # El codec 'mp4v' es común para .mp4
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    writer = cv2.VideoWriter(output_path, fourcc, original_fps, new_size)
    if not writer.isOpened():
        print(f"[Resize] Error: No se pudo crear el VideoWriter para '{output_path}'")
        cap.release()
        return False

    # Leer, redimensionar y escribir cada fotograma
    frame_count = 0
    while True:
        ret, frame = cap.read()
        if not ret:
            break # Fin del video o error de lectura

        resized_frame = cv2.resize(frame, new_size, interpolation=cv2.INTER_AREA)
        writer.write(resized_frame)
        frame_count += 1

    print(f"[Resize] Proceso completado. {frame_count} fotogramas redimensionados y guardados en '{output_path}'.")
    cap.release()
    writer.release()
    return True


def run_pdd_pipeline(video_path: str, user_metadata: dict) -> tuple[bool, dict | str]:
    """
    Ejecuta el pipeline completo de generación de PDD v0.3.
    Incluye redimensionamiento opcional del video.
    """
    print("--- Iniciando Ejecución del Pipeline PDD v0.3 ---")
    print(f"Video de entrada original: {video_path}")
    print(f"Metadatos de usuario: {user_metadata}")

    video_to_analyze = video_path # Por defecto, usar el original
    resized_video_path = None # Ruta al video redimensionado si se crea
    resized_created = False

    # --- PASO NUEVO: Redimensionamiento Opcional ---
    if RESIZE_VIDEO:
        # Crear un nombre de archivo temporal para el video redimensionado
        with tempfile.NamedTemporaryFile(delete=False, suffix=".mp4") as tmp_resized_file:
            resized_video_path = tmp_resized_file.name

        try:
            resize_success = resize_video(video_path, resized_video_path, RESIZE_TARGET_WIDTH)
            if resize_success:
                video_to_analyze = resized_video_path # Usar el video redimensionado para el análisis
                resized_created = True
                print(f"[Pipeline] Usando video redimensionado para análisis: {video_to_analyze}")
            else:
                # Si resize_video devolvió False porque no era necesario o falló al crear writer
                print("[Pipeline] No se usará video redimensionado (ya era pequeño o falló la creación). Usando original.")
                # Asegurarse de eliminar el archivo temporal vacío si se creó
                if os.path.exists(resized_video_path):
                    os.unlink(resized_video_path)
                resized_video_path = None # Indicar que no hay archivo redimensionado
        except Exception as e:
            print(f"[Pipeline] Error inesperado durante el redimensionamiento: {e}\n{traceback.format_exc()}")
            print("[Pipeline] Continuando con el video original.")
            if resized_video_path and os.path.exists(resized_video_path):
                 os.unlink(resized_video_path) # Limpiar si falló
            resized_video_path = None
            # No consideramos esto un fallo fatal del pipeline completo, pero sí un log.
    else:
        print("[Pipeline] Redimensionamiento de video deshabilitado.")
    # --- FIN PASO NUEVO ---


    # --- Fase 1.3: Análisis con IA ---
    print(f"\n[Pipeline] Ejecutando Fase 1.3: Análisis con API sobre '{os.path.basename(video_to_analyze)}'...")
    try:
        if "tu-gcp-project-id" in PROJECT_ID or not PROJECT_ID or not LOCATION or not MODEL_NAME:
             error_msg = "Configuración API incompleta (PROJECT_ID, LOCATION, MODEL_NAME)."
             print(f"[Pipeline] Error: {error_msg}")
             # Limpiar video redimensionado si existe antes de salir
             if resized_created and resized_video_path and os.path.exists(resized_video_path): os.unlink(resized_video_path)
             return False, error_msg

        _, error_fase1 = analyze_video_steps(
            project_id=PROJECT_ID,
            location=LOCATION,
            model_name=MODEL_NAME,
            video_path=video_to_analyze # <--- Pasar el video correcto (original o redimensionado)
        )

        if error_fase1:
            error_msg = f"Fallo en Fase 1.3 (Análisis Video): {error_fase1}"
            print(f"[Pipeline] Error: {error_msg}")
            if resized_created and resized_video_path and os.path.exists(resized_video_path): os.unlink(resized_video_path)
            return False, error_msg
        elif not os.path.exists(JSON_OUTPUT_PATH):
            error_msg = f"Fallo post-Fase 1.3: Archivo JSON no encontrado en '{JSON_OUTPUT_PATH}'."
            print(f"[Pipeline] Error: {error_msg}")
            if resized_created and resized_video_path and os.path.exists(resized_video_path): os.unlink(resized_video_path)
            return False, error_msg
        else:
            print("[Pipeline] Fase 1.3 completada exitosamente.")

    except Exception as e:
        error_msg = f"Error inesperado en Fase 1.3: {e}\n{traceback.format_exc()}"
        print(f"[Pipeline] Error: {error_msg}")
        if resized_created and resized_video_path and os.path.exists(resized_video_path): os.unlink(resized_video_path)
        return False, error_msg

    # --- Fase 2.2 (Adaptada): Extracción de Screenshots ---
    # IMPORTANTE: Los screenshots SIEMPRE se deben extraer del video ORIGINAL
    # para mantener la calidad visual en el PDD.
    print(f"\n[Pipeline] Ejecutando Fase 2.2: Extracción de Screenshots desde video ORIGINAL '{os.path.basename(video_path)}'...")
    try:
        success_fase2 = extract_screenshots(
            json_path=JSON_OUTPUT_PATH,
            video_path=video_path, # <--- Usar video ORIGINAL aquí
            output_dir=SCREENSHOT_DIR
        )
        if not success_fase2:
            print("[Pipeline] Advertencia: Hubo errores durante la extracción de screenshots (Fase 2.2).")
        else:
            print("[Pipeline] Fase 2.2 completada.")
    except Exception as e:
        error_msg = f"Error inesperado en Fase 2.2: {e}\n{traceback.format_exc()}"
        print(f"[Pipeline] Error: {error_msg}")
        if resized_created and resized_video_path and os.path.exists(resized_video_path): os.unlink(resized_video_path)
        return False, error_msg

    # --- Fase 3.3: Generación DOCX y BPMN ---
    print("\n[Pipeline] Ejecutando Fase 3.3: Generación DOCX y BPMN...")
    try:
        final_metadata = DEFAULT_USER_METADATA.copy()
        if "project_name" in user_metadata: final_metadata["project_name"] = user_metadata["project_name"]
        if "project_acronym" in user_metadata: final_metadata["project_acronym"] = user_metadata["project_acronym"]
        if "author_name" in user_metadata: final_metadata["author_name"] = user_metadata["author_name"]
        print(f"[Pipeline] Usando metadata final: {final_metadata}")

        success_fase3 = generate_pdd_docx_v0_3(
            json_path=JSON_OUTPUT_PATH,
            screenshot_dir=SCREENSHOT_DIR,
            output_docx_path=OUTPUT_DOCX_PATH,
            output_bpmn_path=OUTPUT_BPMN_PATH,
            user_metadata=final_metadata
        )
        if not success_fase3:
            error_msg = "Fallo en Fase 3.3 (Generación DOCX/BPMN)."
            print(f"[Pipeline] Error: {error_msg}")
            if resized_created and resized_video_path and os.path.exists(resized_video_path): os.unlink(resized_video_path)
            return False, error_msg
        else:
            print("[Pipeline] Fase 3.3 completada exitosamente.")

    except Exception as e:
        error_msg = f"Error inesperado en Fase 3.3: {e}\n{traceback.format_exc()}"
        print(f"[Pipeline] Error: {error_msg}")
        if resized_created and resized_video_path and os.path.exists(resized_video_path): os.unlink(resized_video_path)
        return False, error_msg

    # --- Limpieza Final y Éxito ---
    # Eliminar video redimensionado si se creó
    if resized_created and resized_video_path and os.path.exists(resized_video_path):
        try:
            os.unlink(resized_video_path)
            print(f"[Pipeline] Video redimensionado temporal eliminado: {resized_video_path}")
        except Exception as e:
            print(f"[Pipeline] Advertencia: Error al eliminar video redimensionado {resized_video_path}: {e}")

    print("\n--- Ejecución del Pipeline PDD v0.3 Finalizada Exitosamente ---")
    result_payload = {
        'docx_path': OUTPUT_DOCX_PATH,
        'bpmn_path': OUTPUT_BPMN_PATH,
        'json_path': JSON_OUTPUT_PATH
    }
    return True, result_payload

